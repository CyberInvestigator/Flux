#!/usr/bin/env python
import logging
import os
import protogen
from FluxCodeGenEngine.PyCodeGenEngine.PluginPydentic.pydantic_class_gen_plugin import PydanticClassGenPlugin
import time


class BeanieClassGenPlugin(PydanticClassGenPlugin):
    """
    Plugin script to convert proto schema to json schema
    """
    # Below field name 'id' must only be used intentionally in beanie pydentic models to generate incremental id value
    # instead of random id value generated by default
    default_id_field_name: str = "id"

    def __init__(self, base_dir_path: str, config_path: str | None = None):
        super().__init__(base_dir_path, config_path)
        self.response_type: str = self.config_yaml["response_type"]

    def handle_field_output(self, field: protogen.Field) -> str:
        field_type = self.proto_to_py_datatype(field)

        match field.cardinality.name.lower():
            case "optional":
                if BeanieClassGenPlugin.flux_fld_index in str(field.proto.options):
                    output_str = f"{field.proto.name}: Indexed({field_type} | None)"
                else:
                    output_str = f"{field.proto.name}: {field_type} | None"
            case "repeated":
                if BeanieClassGenPlugin.flux_fld_index in str(field.proto.options):
                    output_str = f"{field.proto.name}: Indexed(List[{field_type}])"
                else:
                    output_str = f"{field.proto.name}: List[{field_type}]"
            case other:
                if BeanieClassGenPlugin.flux_fld_index in str(field.proto.options):
                    output_str = f"{field.proto.name}: Indexed({field_type})"
                else:
                    output_str = f"{field.proto.name}: {field_type}"

        if (is_id_field := (field.proto.name == BeanieClassGenPlugin.default_id_field_name)) or \
                field.location.leading_comments:
            output_str += f' = Field('

            if is_id_field:
                parent_message_name = field.parent.proto.name
                parent_message_name_snake_cased = self.convert_camel_case_to_specific_case(parent_message_name)
                output_str += f"default_factory={parent_message_name_snake_cased}_id_auto_increment"
            # else not required: If not is_id_field then avoiding text to be added

            if leading_comments := field.location.leading_comments:
                if is_id_field:
                    output_str += ", "
                # else not required: If already not id related text not added then no need to append comma
                if '"' in str(leading_comments):
                    err_str = 'Leading comments can not contain "" (double quotes) to avoid error in generated output,'\
                              f' found in comment: {leading_comments}'
                    logging.exception(err_str)
                    raise Exception(err_str)
                # else not required: If double quotes not found then avoiding
                comments = ", ".join(leading_comments.split("\n"))
                output_str += f'description="{comments}"'
            # else not required: If leading_comments are not present then avoiding text to be added

            output_str += ')\n'
        else:
            output_str += "\n"

        return output_str

    def handle_message_output(self, message: protogen.Message, auto_gen_id: bool = False) -> str:
        if self.response_type.lower() == "snake":
            if auto_gen_id:
                output_str = f"class {message.proto.name}(Document, IncrementalIdCacheBaseModel):\n"
            else:
                if message in self.root_message_list:
                    output_str = f"class {message.proto.name}(Document):\n"
                else:
                    output_str = f"class {message.proto.name}(BaseModel):\n"
        elif self.response_type.lower() == "camel":
            if auto_gen_id:
                output_str = f"class {message.proto.name}(Document, IncrementalIdCamelCacheBaseModel):\n"
            else:
                if message in self.root_message_list:
                    output_str = f"class {message.proto.name}(Document, CamelCacheBaseModel):\n"
                else:
                    output_str = f"class {message.proto.name}(BaseModel):\n"
        else:
            err_str = f"{self.response_type} is not supported response type"
            logging.exception(err_str)
            raise Exception(err_str)

        # Adding docstring if message lvl comment available
        if leading_comments := message.location.leading_comments:
            output_str += '    """\n'
            if '"' in str(leading_comments):
                err_str = 'Leading comments can not contain "" (double quotes) to avoid error in generated output,' \
                          f' found in comment: {leading_comments}'
                logging.exception(err_str)
                raise Exception(err_str)
            # else not required: If double quotes not found then avoiding
            comments = ", ".join(leading_comments.split("\n"))
            comments_multiline = [comments[0+i:100+i] for i in range(0, len(comments), 100)]
            for comments_line in comments_multiline:
                output_str += f"        {comments_line}\n"

            output_str += '    """\n'

        for field in message.fields:
            if auto_gen_id and field.proto.name == BeanieClassGenPlugin.default_id_field_name:
                output_str += "    _max_id_val: ClassVar[int | None] = None\n"
                output_str += "    _mutex: ClassVar[Lock] = Lock()\n"
                output_str += f"    id: int = Field(default_factory=(lambda: {message.proto.name}.next_id())," \
                              " description='Server generated unique Id')\n"
                continue
            # else not required: If auto_gen_id is true and field is named other than id, then skip adding it to output
            output_str += ' '*4 + self.handle_field_output(field)

        return output_str

    def handle_imports(self) -> str:
        output_str = "from beanie import Indexed, Document\n"
        output_str += "from pydantic import BaseModel, Field\n"
        output_str += "import datetime\n"
        output_str += "from threading import Lock\n"
        incremental_id_camel_base_model_path = self.import_path_from_os_path("PY_CODE_GEN_CORE_PATH",
                                                                             "incremental_id_basemodel")
        if self.response_type.lower() == "snake":
            output_str += f'from {incremental_id_camel_base_model_path} import IncrementalIdCacheBaseModel\n'
        elif self.response_type.lower() == "camel":
            output_str += f'from {incremental_id_camel_base_model_path} import IncrementalIdCamelCacheBaseModel, ' \
                          f'CamelCacheBaseModel\n'
        else:
            err_str = f"{self.response_type} is not supported response type"
            logging.exception(err_str)
            raise Exception(err_str)

        if self.enum_list:
            if self.enum_type == "int_enum":
                output_str += "from enum import IntEnum\n"
            elif self.enum_type == "str_enum":
                output_str += "from enum import auto\n"
                output_str += "from fastapi_utils.enums import StrEnum\n"
            # else not required: if enum type is not proper then it would be already handled in init
        output_str += "from typing import List, ClassVar\n\n\n"
        return output_str

    def handle_pydantic_class_gen(self, file: protogen.File) -> str:
        self.load_root_and_non_root_messages_in_dicts(file.messages)

        self.sort_message_order()

        output_str = self.handle_imports()

        for enum in self.enum_list:
            output_str += self.handle_enum_output(enum, self.enum_type)

        for message in self.ordered_message_list:
            is_int_id_type: bool = False
            if BeanieClassGenPlugin.default_id_field_name in [field.proto.name for field in message.fields]:
                is_int_id_type = True
            output_str += self.handle_message_output(message, is_int_id_type)
            output_str += "\n\n"

        return output_str


if __name__ == "__main__":
    def main():
        project_dir_path = os.getenv("PROJECT_PATH")
        config_path = os.getenv("CONFIG_PATH")
        if (debug_sleep_time := os.getenv("DEBUG_SLEEP_TIME")) is not None and \
                isinstance(debug_sleep_time := int(debug_sleep_time), int):
            time.sleep(debug_sleep_time)
        # else not required: Avoid if env var is not set or if value cant be type-cased to int
        beanie_class_gen_plugin = BeanieClassGenPlugin(project_dir_path, config_path)
        beanie_class_gen_plugin.process()

    main()
